{"version":1,"Request":{"Prompt":"Severity Code Description Project File Line Suppression State\r\nError NETSDK1005 Assets file \u0027D:\\GitHub2023\\WorldTimeLive\\obj\\project.assets.json\u0027 doesn\u0027t have a target for \u0027net7.0-android33.0\u0027. Ensure that restore has run and that you have included \u0027net7.0-android33.0\u0027 in the TargetFrameworks for your project. WorldTime C:\\Program Files\\dotnet\\sdk\\7.0.401\\Sdks\\Microsoft.NET.Sdk\\targets\\Microsoft.PackageDependencyResolution.targets 266","Context":{"VisibleDocuments":[{"Content":"\u003C!--\r\n***********************************************************************************************\r\nMicrosoft.PackageDependencyResolution.targets\r\n\r\nWARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have\r\n          created a backup copy.  Incorrect changes to this file will make it\r\n          impossible to load or build your projects from the command-line or the IDE.\r\n\r\nCopyright (c) .NET Foundation. All rights reserved.\r\n***********************************************************************************************\r\n--\u003E\r\n\u003CProject xmlns=\u0022http://schemas.microsoft.com/developer/msbuild/2003\u0022\u003E\r\n\r\n  \u003C!--\r\n    *************************************\r\n    1. INPUT PROPERTIES\r\n    - That configure the PackageDependency targets\r\n    *************************************\r\n    --\u003E\r\n\r\n  \u003C!-- General Properties --\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003CProjectAssetsFile Condition=\u0022\u0027$(ProjectAssetsFile)\u0027 == \u0027\u0027\u0022\u003E$(MSBuildProjectExtensionsPath)/project.assets.json\u003C/ProjectAssetsFile\u003E\r\n    \u003CProjectAssetsFile\u003E$([MSBuild]::NormalizePath($(MSBuildProjectDirectory), $(ProjectAssetsFile)))\u003C/ProjectAssetsFile\u003E\r\n\r\n    \u003C!-- Note that the assets.cache file has contents that are unique to the current TFM and configuration and therefore cannot\r\n         be stored in a shared directory next to the assets.json file --\u003E\r\n    \u003CProjectAssetsCacheFile Condition=\u0022\u0027$(ProjectAssetsCacheFile)\u0027 == \u0027\u0027\u0022\u003E$(IntermediateOutputPath)$(MSBuildProjectName).assets.cache\u003C/ProjectAssetsCacheFile\u003E\r\n    \u003CProjectAssetsCacheFile\u003E$([MSBuild]::NormalizePath($(MSBuildProjectDirectory), $(ProjectAssetsCacheFile)))\u003C/ProjectAssetsCacheFile\u003E\r\n\r\n    \u003C!-- Don\u0027t copy local for netstandard projects. --\u003E\r\n    \u003CCopyLocalLockFileAssemblies Condition=\u0022\u0027$(CopyLocalLockFileAssemblies)\u0027 == \u0027\u0027 and\r\n                                            \u0027$(TargetFrameworkIdentifier)\u0027 == \u0027.NETStandard\u0027\u0022\u003Efalse\u003C/CopyLocalLockFileAssemblies\u003E\r\n\r\n    \u003C!-- Don\u0027t copy local for netcoreapp projects before 3.0 or non-exe and non-component projects. --\u003E\r\n    \u003CCopyLocalLockFileAssemblies Condition=\u0022\u0027$(CopyLocalLockFileAssemblies)\u0027 == \u0027\u0027 and\r\n                                            \u0027$(TargetFrameworkIdentifier)\u0027 == \u0027.NETCoreApp\u0027 and\r\n                                            (\u0027$(_TargetFrameworkVersionWithoutV)\u0027 \u0026lt; \u00273.0\u0027 or\r\n                                             (\u0027$(HasRuntimeOutput)\u0027 != \u0027true\u0027 and \u0027$(EnableDynamicLoading)\u0027 != \u0027true\u0027))\u0022\u003Efalse\u003C/CopyLocalLockFileAssemblies\u003E\r\n\r\n    \u003C!-- All other project types should copy local. --\u003E\r\n    \u003CCopyLocalLockFileAssemblies Condition=\u0022\u0027$(CopyLocalLockFileAssemblies)\u0027 == \u0027\u0027\u0022\u003Etrue\u003C/CopyLocalLockFileAssemblies\u003E\r\n\r\n    \u003CContentPreprocessorOutputDirectory Condition=\u0022\u0027$(ContentPreprocessorOutputDirectory)\u0027 == \u0027\u0027\u0022\u003E$(IntermediateOutputPath)NuGet\\\u003C/ContentPreprocessorOutputDirectory\u003E\r\n\r\n    \u003CUseTargetPlatformAsNuGetTargetMoniker Condition=\u0022\u0027$(UseTargetPlatformAsNuGetTargetMoniker)\u0027 == \u0027\u0027 AND \u0027$(TargetFrameworkMoniker)\u0027 == \u0027.NETCore,Version=v5.0\u0027\u0022\u003Etrue\u003C/UseTargetPlatformAsNuGetTargetMoniker\u003E\r\n    \u003CNuGetTargetMoniker Condition=\u0022\u0027$(NuGetTargetMoniker)\u0027 == \u0027\u0027 AND \u0027$(UseTargetPlatformAsNuGetTargetMoniker)\u0027 == \u0027true\u0027\u0022\u003E$(TargetPlatformIdentifier),Version=v$([System.Version]::Parse(\u0027$(TargetPlatformMinVersion)\u0027).ToString(3))\u003C/NuGetTargetMoniker\u003E\r\n    \u003CNuGetTargetMoniker Condition=\u0022\u0027$(NuGetTargetMoniker)\u0027 == \u0027\u0027 AND \u0027$(UseTargetPlatformAsNuGetTargetMoniker)\u0027 != \u0027true\u0027\u0022\u003E$(TargetFrameworkMoniker)\u003C/NuGetTargetMoniker\u003E\r\n\r\n    \u003CEmitAssetsLogMessages Condition=\u0022\u0027$(EmitAssetsLogMessages)\u0027 == \u0027\u0027\u0022\u003Etrue\u003C/EmitAssetsLogMessages\u003E\r\n\r\n    \u003C!-- Setting this property to true restores pre-16.7 behaviour of ResolvePackageDependencies to produce\r\n         TargetDefinitions, FileDefinitions and FileDependencies items. --\u003E\r\n    \u003CEmitLegacyAssetsFileItems Condition=\u0022\u0027$(EmitLegacyAssetsFileItems)\u0027 == \u0027\u0027\u0022\u003Efalse\u003C/EmitLegacyAssetsFileItems\u003E\r\n\r\n    \u003C!-- A flag that NuGet packages containing multi-targeted analyzers can check to see if the NuGet package needs to do\r\n         its own multi-targeting logic, or if the current SDK targets will pick the assets correctly. --\u003E\r\n    \u003CSupportsRoslynComponentVersioning\u003Etrue\u003C/SupportsRoslynComponentVersioning\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003C!-- Target Moniker \u002B RID--\u003E\r\n  \u003CPropertyGroup Condition=\u0022\u0027$(_NugetTargetMonikerAndRID)\u0027 == \u0027\u0027\u0022\u003E\r\n    \u003C_NugetTargetMonikerAndRID Condition=\u0022\u0027$(RuntimeIdentifier)\u0027 == \u0027\u0027\u0022\u003E$(NuGetTargetMoniker)\u003C/_NugetTargetMonikerAndRID\u003E\r\n    \u003C_NugetTargetMonikerAndRID Condition=\u0022\u0027$(RuntimeIdentifier)\u0027 != \u0027\u0027\u0022\u003E$(NuGetTargetMoniker)/$(RuntimeIdentifier)\u003C/_NugetTargetMonikerAndRID\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003C!-- Embed all project.assets.json files into the binary log when building with /bl --\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CEmbedInBinlog Include=\u0022$(ProjectAssetsFile)\u0022 Condition=\u0022$(EmbedProjectAssetsFile) != false AND Exists(\u0027$(ProjectAssetsFile)\u0027)\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n\r\n  \u003C!--\r\n    *************************************\r\n    2. EXTERNAL PROPERTIES and ITEMS\r\n    - Override or add to external targets\r\n    *************************************\r\n    --\u003E\r\n\r\n  \u003CPropertyGroup\u003E\r\n    \u003CResolveAssemblyReferencesDependsOn\u003E\r\n      $(ResolveAssemblyReferencesDependsOn);\r\n      ResolvePackageDependenciesForBuild;\r\n      _HandlePackageFileConflicts;\r\n    \u003C/ResolveAssemblyReferencesDependsOn\u003E\r\n\r\n    \u003CPrepareResourcesDependsOn\u003E\r\n      ResolvePackageDependenciesForBuild;\r\n      _HandlePackageFileConflicts;\r\n      $(PrepareResourcesDependsOn)\r\n    \u003C/PrepareResourcesDependsOn\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003C!-- Common tokens used in preprocessed content files --\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CPreprocessorValue Include=\u0022rootnamespace\u0022\u003E\r\n      \u003CValue\u003E$(RootNamespace)\u003C/Value\u003E\r\n    \u003C/PreprocessorValue\u003E\r\n    \u003CPreprocessorValue Include=\u0022assemblyname\u0022\u003E\r\n      \u003CValue\u003E$(AssemblyName)\u003C/Value\u003E\r\n    \u003C/PreprocessorValue\u003E\r\n    \u003CPreprocessorValue Include=\u0022fullpath\u0022\u003E\r\n      \u003CValue\u003E$(MSBuildProjectDirectory)\u003C/Value\u003E\r\n    \u003C/PreprocessorValue\u003E\r\n    \u003CPreprocessorValue Include=\u0022outputfilename\u0022\u003E\r\n      \u003CValue\u003E$(TargetFileName)\u003C/Value\u003E\r\n    \u003C/PreprocessorValue\u003E\r\n    \u003CPreprocessorValue Include=\u0022filename\u0022\u003E\r\n      \u003CValue\u003E$(MSBuildProjectFile)\u003C/Value\u003E\r\n    \u003C/PreprocessorValue\u003E\r\n    \u003CPreprocessorValue Include=\u0022@(NuGetPreprocessorValue)\u0022 Exclude=\u0022@(PreprocessorValue)\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n\r\n  \u003C!--\r\n    This will prevent RAR from spending time locating dependencies and related files for assemblies\r\n    that came from packages. PackageReference should already be promoted to a closure of Reference\r\n    items and we are responsible for adding package relates files to CopyLocal items, not RAR. This\r\n    is only configurable as a compat opt-out in case skipping the slow RAR code breaks something.\r\n  --\u003E\r\n  \u003CPropertyGroup Condition=\u0022\u0027$(MarkPackageReferencesAsExternallyResolved)\u0027 == \u0027\u0027\u0022\u003E\r\n    \u003CMarkPackageReferencesAsExternallyResolved\u003Etrue\u003C/MarkPackageReferencesAsExternallyResolved\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003C!--\r\n    *************************************\r\n    3. BUILD TARGETS\r\n    - Override the Depends-On properties, or the individual targets\r\n    *************************************\r\n    --\u003E\r\n\r\n  \u003C!--\r\n    ============================================================\r\n                     ResolvePackageDependenciesForBuild\r\n\r\n    Populate items for build. This is triggered before target\r\n    \u0022AssignProjectConfiguration\u0022 to ensure ProjectReference items\r\n    are populated before ResolveProjectReferences is run.\r\n    ============================================================\r\n    --\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003CResolvePackageDependenciesForBuildDependsOn\u003E\r\n      ResolveLockFileReferences;\r\n      ResolveLockFileAnalyzers;\r\n      ResolveLockFileCopyLocalFiles;\r\n      ResolveRuntimePackAssets;\r\n      RunProduceContentAssets;\r\n      IncludeTransitiveProjectReferences\r\n    \u003C/ResolvePackageDependenciesForBuildDependsOn\u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CTarget Name=\u0022ResolvePackageDependenciesForBuild\u0022\r\n          Condition=\u0022 (\u0027$(DesignTimeBuild)\u0027 != \u0027true\u0027 and \u0027$(_CleaningWithoutRebuilding)\u0027 != \u0027true\u0027)\r\n                      Or Exists(\u0027$(ProjectAssetsFile)\u0027)\u0022\r\n          BeforeTargets=\u0022AssignProjectConfiguration\u0022\r\n          DependsOnTargets=\u0022$(ResolvePackageDependenciesForBuildDependsOn)\u0022 /\u003E\r\n\r\n  \u003C!--\r\n    *************************************\r\n    4. Package Dependency TASK and TARGETS\r\n    - Raise the lock file to MSBuild Items and create derived items\r\n    *************************************\r\n    --\u003E\r\n\r\n  \u003C!--\r\n    ============================================================\r\n                     RunResolvePackageDependencies\r\n\r\n    Generate Definitions and Dependencies based on ResolvePackageDependencies task\r\n    ============================================================\r\n    --\u003E\r\n\r\n  \u003CUsingTask TaskName=\u0022Microsoft.NET.Build.Tasks.ResolvePackageDependencies\u0022\r\n             AssemblyFile=\u0022$(MicrosoftNETBuildTasksAssembly)\u0022 /\u003E\r\n  \u003CUsingTask TaskName=\u0022Microsoft.NET.Build.Tasks.CheckForTargetInAssetsFile\u0022\r\n           AssemblyFile=\u0022$(MicrosoftNETBuildTasksAssembly)\u0022 /\u003E\r\n  \u003CUsingTask TaskName=\u0022Microsoft.NET.Build.Tasks.JoinItems\u0022\r\n           AssemblyFile=\u0022$(MicrosoftNETBuildTasksAssembly)\u0022 /\u003E\r\n  \u003CUsingTask TaskName=\u0022Microsoft.NET.Build.Tasks.ResolvePackageAssets\u0022\r\n            AssemblyFile=\u0022$(MicrosoftNETBuildTasksAssembly)\u0022 /\u003E\r\n  \r\n  \u003C!-- The condition on this target causes it to be skipped during design-time builds if\r\n        the restore operation hasn\u0027t run yet.  This is to avoid displaying an error in\r\n        the Visual Studio error list when a project is created before NuGet restore has\r\n        run and created the assets file. --\u003E\r\n  \u003CTarget Name=\u0022RunResolvePackageDependencies\u0022\r\n          Condition=\u0022 \u0027$(DesignTimeBuild)\u0027 != \u0027true\u0027 Or Exists(\u0027$(ProjectAssetsFile)\u0027)\u0022\u003E\r\n\r\n    \u003C!-- Verify that the assets file has a target for the right framework.  Otherwise, if we restored for the\r\n         wrong framework, we\u0027d end up finding no references to pass to the compiler, and we\u0027d get a ton of\r\n         compile errors. --\u003E\r\n    \u003CCheckForTargetInAssetsFile\r\n      AssetsFilePath=\u0022$(ProjectAssetsFile)\u0022\r\n      TargetFramework=\u0022$(TargetFramework)\u0022\r\n      RuntimeIdentifier=\u0022$(RuntimeIdentifier)\u0022\r\n      Condition=\u0022 \u0027$(DesignTimeBuild)\u0027 != \u0027true\u0027\u0022/\u003E\r\n\r\n    \u003C!-- Included for backwards compatibility when the EmitLegacyAssetsFileItems property is true. --\u003E\r\n    \u003CResolvePackageDependencies\r\n      ProjectPath=\u0022$(MSBuildProjectFullPath)\u0022\r\n      ProjectAssetsFile=\u0022$(ProjectAssetsFile)\u0022\r\n      ProjectLanguage=\u0022$(Language)\u0022\r\n      TargetFramework=\u0022$(TargetFramework)\u0022\r\n      ContinueOnError=\u0022ErrorAndContinue\u0022\r\n      Condition=\u0022\u0027$(EmitLegacyAssetsFileItems)\u0027 == \u0027true\u0027\u0022\u003E\r\n\r\n      \u003COutput TaskParameter=\u0022PackageDefinitions\u0022 ItemName=\u0022PackageDefinitions\u0022 /\u003E\r\n      \u003COutput TaskParameter=\u0022PackageDependencies\u0022 ItemName=\u0022PackageDependencies\u0022 /\u003E\r\n      \u003COutput TaskParameter=\u0022TargetDefinitions\u0022 ItemName=\u0022TargetDefinitions\u0022 /\u003E\r\n      \u003COutput TaskParameter=\u0022FileDefinitions\u0022 ItemName=\u0022FileDefinitions\u0022 /\u003E\r\n      \u003COutput TaskParameter=\u0022FileDependencies\u0022 ItemName=\u0022FileDependencies\u0022 /\u003E\r\n    \u003C/ResolvePackageDependencies\u003E\r\n\r\n  \u003C/Target\u003E\r\n\r\n  \u003C!-- Reads the version of the compiler APIs that are currently being used in order to pick the correct Roslyn components. --\u003E\r\n  \u003CTarget Name=\u0022_ResolveCompilerVersion\u0022\r\n          Condition=\u0022\u0027$(CompilerApiVersion)\u0027 == \u0027\u0027 And\r\n                     (\u0027$(Language)\u0027 == \u0027C#\u0027 Or \u0027$(Language)\u0027 == \u0027VB\u0027) And\r\n                     Exists(\u0027$(RoslynTargetsPath)\\Microsoft.Build.Tasks.CodeAnalysis.dll\u0027)\u0022\u003E\r\n    \r\n    \u003CGetAssemblyIdentity AssemblyFiles=\u0022$(RoslynTargetsPath)\\Microsoft.Build.Tasks.CodeAnalysis.dll\u0022\u003E\r\n      \u003COutput TaskParameter=\u0022Assemblies\u0022 ItemName=\u0022_CodeAnalysisIdentity\u0022 /\u003E\r\n    \u003C/GetAssemblyIdentity\u003E\r\n\r\n    \u003CPropertyGroup\u003E\r\n      \u003C_RoslynApiVersion\u003E$([System.Version]::Parse(%(_CodeAnalysisIdentity.Version)).Major).$([System.Version]::Parse(%(_CodeAnalysisIdentity.Version)).Minor)\u003C/_RoslynApiVersion\u003E\r\n      \u003CCompilerApiVersion\u003Eroslyn$(_RoslynApiVersion)\u003C/CompilerApiVersion\u003E\r\n    \u003C/PropertyGroup\u003E\r\n    \r\n  \u003C/Target\u003E\r\n\r\n  \u003CTarget Name=\u0022ResolvePackageAssets\u0022\r\n          Condition=\u0022(\u0027$(DesignTimeBuild)\u0027 != \u0027true\u0027 Or Exists(\u0027$(ProjectAssetsFile)\u0027)) And \u0027$(SkipResolvePackageAssets)\u0027 != \u0027true\u0027\u0022\r\n          DependsOnTargets=\u0022ProcessFrameworkReferences;_DefaultMicrosoftNETPlatformLibrary;_ComputePackageReferencePublish;_ResolveCompilerVersion\u0022\u003E\r\n\r\n    \u003CPropertyGroup Condition=\u0022\u0027$(TargetFrameworkIdentifier)\u0027 == \u0027.NETCoreApp\u0027\r\n                          and \u0027$(_TargetFrameworkVersionWithoutV)\u0027 \u003E= \u00273.0\u0027\r\n                          and \u0027$(UseAppHostFromAssetsFile)\u0027 == \u0027\u0027\u0022\u003E\r\n      \u003C!-- For .NET Core 3.0 and higher, we\u0027ll get the apphost from an apphost pack (via ProcessFrameworkReferences) --\u003E\r\n      \u003CUseAppHostFromAssetsFile\u003Efalse\u003C/UseAppHostFromAssetsFile\u003E\r\n    \u003C/PropertyGroup\u003E\r\n    \u003CPropertyGroup Condition=\u0022\u0027$(UseAppHostFromAssetsFile)\u0027 == \u0027\u0027\u0022\u003E\r\n      \u003CUseAppHostFromAssetsFile\u003Etrue\u003C/UseAppHostFromAssetsFile\u003E\r\n    \u003C/PropertyGroup\u003E\r\n\r\n    \u003CPropertyGroup Condition=\u0022\u0027$(EnsureRuntimePackageDependencies)\u0027 == \u0027\u0027\r\n                          and \u0027$(TargetFrameworkIdentifier)\u0027 == \u0027.NETCoreApp\u0027\r\n                          and \u0027$(_TargetFrameworkVersionWithoutV)\u0027 \u0026lt; \u00273.0\u0027\r\n                          and \u0027$(EnsureNETCoreAppRuntime)\u0027 != \u0027false\u0027\u0022\u003E\r\n      \u003CEnsureRuntimePackageDependencies\u003Etrue\u003C/EnsureRuntimePackageDependencies\u003E\r\n    \u003C/PropertyGroup\u003E\r\n\r\n    \u003C!-- Only copy local runtime target assets if targeting netcoreapp --\u003E\r\n    \u003CPropertyGroup Condition=\u0022\u0027$(CopyLocalRuntimeTargetAssets)\u0027 == \u0027\u0027 and \u0027$(TargetFrameworkIdentifier)\u0027 == \u0027.NETCoreApp\u0027\u0022\u003E\r\n      \u003CCopyLocalRuntimeTargetAssets\u003Etrue\u003C/CopyLocalRuntimeTargetAssets\u003E\r\n    \u003C/PropertyGroup\u003E\r\n\r\n    \u003CItemGroup\u003E\r\n      \u003C_PackAsToolShimRuntimeIdentifiers Condition=\u0022@(_PackAsToolShimRuntimeIdentifiers) ==\u0027\u0027\u0022 Include=\u0022$(PackAsToolShimRuntimeIdentifiers)\u0022/\u003E\r\n\r\n      \u003C!-- Pass these packages into the ResolvePackageAssets task to verify that the restored versions of the packages\r\n           match the expected version --\u003E\r\n      \u003CExpectedPlatformPackages Include=\u0022@(PackageReference)\u0022 Condition=\u0022\u0027%(Identity)\u0027 == \u0027Microsoft.NETCore.App\u0027\u0022 /\u003E\r\n      \u003CExpectedPlatformPackages Include=\u0022@(PackageReference)\u0022 Condition=\u0022\u0027%(Identity)\u0027 == \u0027Microsoft.AspNetCore.App\u0027\u0022 /\u003E\r\n      \u003CExpectedPlatformPackages Include=\u0022@(PackageReference)\u0022 Condition=\u0022\u0027%(Identity)\u0027 == \u0027Microsoft.AspNetCore.All\u0027\u0022 /\u003E\r\n    \u003C/ItemGroup\u003E\r\n\r\n    \u003CResolvePackageAssets\r\n      ProjectAssetsFile=\u0022$(ProjectAssetsFile)\u0022\r\n      ProjectAssetsCacheFile=\u0022$(ProjectAssetsCacheFile)\u0022\r\n      ProjectPath=\u0022$(MSBuildProjectFullPath)\u0022\r\n      ProjectLanguage=\u0022$(Language)\u0022\r\n      CompilerApiVersion=\u0022$(CompilerApiVersion)\u0022\r\n      EmitAssetsLogMessages=\u0022$(EmitAssetsLogMessages)\u0022\r\n      TargetFramework=\u0022$(TargetFramework)\u0022\r\n      RuntimeIdentifier=\u0022$(RuntimeIdentifier)\u0022\r\n      PlatformLibraryName=\u0022$(MicrosoftNETPlatformLibrary)\u0022\r\n      RuntimeFrameworks=\u0022@(RuntimeFramework)\u0022\r\n      IsSelfContained=\u0022$(SelfContained)\u0022\r\n      MarkPackageReferencesAsExternallyResolved=\u0022$(MarkPackageReferencesAsExternallyResolved)\u0022\r\n      DisablePackageAssetsCache=\u0022$(DisablePackageAssetsCache)\u0022\r\n      DisableFrameworkAssemblies=\u0022$(DisableLockFileFrameworks)\u0022\r\n      CopyLocalRuntimeTargetAssets=\u0022$(CopyLocalRuntimeTargetAssets)\u0022\r\n      DisableTransitiveProjectReferences=\u0022$(DisableTransitiveProjectReferences)\u0022\r\n      DisableTransitiveFrameworkReferences=\u0022$(DisableTransitiveFrameworkReferences)\u0022\r\n      DotNetAppHostExecutableNameWithoutExtension=\u0022$(_DotNetAppHostExecutableNameWithoutExtension)\u0022\r\n      ShimRuntimeIdentifiers=\u0022@(_PackAsToolShimRuntimeIdentifiers)\u0022\r\n      EnsureRuntimePackageDependencies=\u0022$(EnsureRuntimePackageDependencies)\u0022\r\n      VerifyMatchingImplicitPackageVersion=\u0022$(VerifyMatchingImplicitPackageVersion)\u0022\r\n      ExpectedPlatformPackages=\u0022@(ExpectedPlatformPackages)\u0022\r\n      SatelliteResourceLanguages=\u0022$(SatelliteResourceLanguages)\u0022\r\n      DesignTimeBuild=\u0022$(DesignTimeBuild)\u0022\r\n      ContinueOnError=\u0022$(ContinueOnError)\u0022\r\n      PackageReferences=\u0022@(PackageReference)\u0022\r\n      DefaultImplicitPackages= \u0022$(DefaultImplicitPackages)\u0022\u003E\r\n\r\n      \u003C!-- NOTE: items names here are inconsistent because they match prior implementation\r\n          (that was spread across different tasks/targets) for backwards compatibility.  --\u003E\r\n      \u003COutput TaskParameter=\u0022Analyzers\u0022 ItemName=\u0022ResolvedAnalyzers\u0022 /\u003E\r\n      \u003COutput TaskParameter=\u0022ApphostsForShimRuntimeIdentifiers\u0022 ItemName=\u0022_ApphostsForShimRuntimeIdentifiersResolvePackageAssets\u0022 /\u003E\r\n      \u003COutput TaskParameter=\u0022ContentFilesToPreprocess\u0022 ItemName=\u0022_ContentFilesToPreprocess\u0022 /\u003E\r\n      \u003COutput TaskParameter=\u0022DebugSymbolsFiles\u0022 ItemName=\u0022_DebugSymbolsFiles\u0022 /\u003E\r\n      \u003COutput TaskParameter=\u0022ReferenceDocumentationFiles\u0022 ItemName=\u0022_ReferenceDocumentationFiles\u0022 /\u003E\r\n      \u003COutput TaskParameter=\u0022FrameworkAssemblies\u0022 ItemName=\u0022ResolvedFrameworkAssemblies\u0022 /\u003E\r\n      \u003COutput TaskParameter=\u0022FrameworkReferences\u0022 ItemName=\u0022TransitiveFrameworkReference\u0022 /\u003E\r\n      \u003COutput TaskParameter=\u0022NativeLibraries\u0022 ItemName=\u0022NativeCopyLocalItems\u0022 /\u003E\r\n      \u003COutput TaskParameter=\u0022ResourceAssemblies\u0022 ItemName=\u0022ResourceCopyLocalItems\u0022 /\u003E\r\n      \u003COutput TaskParameter=\u0022RuntimeAssemblies\u0022 ItemName=\u0022RuntimeCopyLocalItems\u0022 /\u003E\r\n      \u003COutput TaskParameter=\u0022RuntimeTargets\u0022 ItemName=\u0022RuntimeTargetsCopyLocalItems\u0022 /\u003E\r\n      \u003COutput TaskParameter=\u0022CompileTimeAssemblies\u0022 ItemName=\u0022ResolvedCompileFileDefinitions\u0022 /\u003E\r\n      \u003COutput TaskParameter=\u0022TransitiveProjectReferences\u0022 ItemName=\u0022_TransitiveProjectReferences\u0022 /\u003E\r\n      \u003COutput TaskParameter=\u0022PackageFolders\u0022 ItemName=\u0022AssetsFilePackageFolder\u0022 /\u003E\r\n      \u003COutput TaskParameter=\u0022PackageDependencies\u0022 ItemName=\u0022PackageDependencies\u0022 /\u003E\r\n      \u003COutput TaskParameter=\u0022PackageDependenciesDesignTime\u0022 ItemName=\u0022_PackageDependenciesDesignTime\u0022 /\u003E\r\n    \u003C/ResolvePackageAssets\u003E\r\n\r\n    \u003CItemGroup Condition=\u0022\u0027$(CopyDebugSymbolFilesFromPackages)\u0027 == \u0027true\u0027\u0022\u003E\r\n      \u003CReferenceCopyLocalPaths Include=\u0022@(_DebugSymbolsFiles)\u0022\u003E\u003C/ReferenceCopyLocalPaths\u003E\r\n    \u003C/ItemGroup\u003E\r\n\r\n    \u003CItemGroup Condition=\u0022\u0027$(CopyDocumentationFilesFromPackages)\u0027 == \u0027true\u0027\u0022\u003E\r\n      \u003CReferenceCopyLocalPaths Include=\u0022@(_ReferenceDocumentationFiles)\u0022\u003E\u003C/ReferenceCopyLocalPaths\u003E\r\n    \u003C/ItemGroup\u003E\r\n\r\n    \u003CItemGroup Condition=\u0022\u0027$(UseAppHostFromAssetsFile)\u0027 == \u0027true\u0027\u0022\u003E\r\n      \u003C_NativeRestoredAppHostNETCore Include=\u0022@(NativeCopyLocalItems)\u0022\r\n                                     Condition=\u0022\u0027%(NativeCopyLocalItems.FileName)%(NativeCopyLocalItems.Extension)\u0027 == \u0027$(_DotNetAppHostExecutableName)\u0027\u0022/\u003E\r\n    \u003C/ItemGroup\u003E\r\n\r\n    \u003CItemGroup Condition=\u0022\u0027@(_ApphostsForShimRuntimeIdentifiers)\u0027 == \u0027\u0027\u0022\u003E\r\n      \u003C_ApphostsForShimRuntimeIdentifiers Include=\u0022@(_ApphostsForShimRuntimeIdentifiersResolvePackageAssets)\u0022/\u003E\r\n    \u003C/ItemGroup\u003E\r\n\r\n  \u003C/Target\u003E\r\n\r\n  \u003C!--\r\n    ============================================================\r\n                     ResolvePackageDependenciesDesignTime\r\n\r\n    Aggregate the dependencies produced by ResolvePackageDependencies to a form\r\n    that\u0027s consumable by an IDE to display package dependencies.\r\n    ============================================================\r\n    --\u003E\r\n\r\n  \u003CTarget Name=\u0022ResolvePackageDependenciesDesignTime\u0022\r\n          Returns=\u0022@(_PackageDependenciesDesignTime)\u0022\r\n          DependsOnTargets=\u0022ResolvePackageAssets;RunResolvePackageDependencies;ResolveAssemblyReferencesDesignTime\u0022 /\u003E\r\n\r\n  \u003C!--\r\n    ============================================================\r\n                     CollectSDKReferencesDesignTime\r\n\r\n    Aggregates the sdk specified as project items and implicit\r\n    packages references.\r\n    ============================================================\r\n    --\u003E\r\n  \u003CUsingTask TaskName=\u0022Microsoft.NET.Build.Tasks.CollectSDKReferencesDesignTime\u0022\r\n         AssemblyFile=\u0022$(MicrosoftNETBuildTasksAssembly)\u0022 /\u003E\r\n\r\n  \u003CTarget Name=\u0022CollectSDKReferencesDesignTime\u0022\r\n          Returns=\u0022@(_SDKReference)\u0022\r\n          DependsOnTargets=\u0022CollectPackageReferences\u0022\u003E\r\n\r\n    \u003CCollectSDKReferencesDesignTime\r\n          SdkReferences=\u0022@(SdkReference)\u0022\r\n          PackageReferences=\u0022@(PackageReference)\u0022\r\n          DefaultImplicitPackages=\u0022$(DefaultImplicitPackages)\u0022\u003E\r\n\r\n      \u003COutput TaskParameter=\u0022SDKReferencesDesignTime\u0022 ItemName=\u0022_SDKReference\u0022 /\u003E\r\n    \u003C/CollectSDKReferencesDesignTime\u003E\r\n\r\n  \u003C/Target\u003E\r\n\r\n  \u003C!--\r\n    ============================================================\r\n                     CollectResolvedSDKReferencesDesignTime\r\n\r\n    Aggregates the sdk specified as project items and implicit\r\n    packages produced by ResolvePackageDependencies.\r\n    ============================================================\r\n    --\u003E\r\n  \u003CTarget Name=\u0022CollectResolvedSDKReferencesDesignTime\u0022\r\n          Returns=\u0022@(_ResolvedSDKReference)\u0022\r\n          DependsOnTargets=\u0022ResolveSDKReferencesDesignTime;CollectPackageReferences\u0022\u003E\r\n\r\n    \u003CCollectSDKReferencesDesignTime\r\n          SdkReferences=\u0022@(ResolvedSdkReference)\u0022\r\n          PackageReferences=\u0022@(PackageReference)\u0022\r\n          DefaultImplicitPackages=\u0022$(DefaultImplicitPackages)\u0022\u003E\r\n\r\n      \u003COutput TaskParameter=\u0022SDKReferencesDesignTime\u0022 ItemName=\u0022_ResolvedSDKReference\u0022 /\u003E\r\n    \u003C/CollectSDKReferencesDesignTime\u003E\r\n\r\n  \u003C/Target\u003E\r\n\r\n  \u003C!--\r\n    ============================================================\r\n                     RunProduceContentAssets\r\n\r\n    Process content assets by handling preprocessing tokens where necessary, and\r\n    produce copy local items, content items grouped by \u0022build action\u0022 and file writes\r\n    ============================================================\r\n    --\u003E\r\n\r\n  \u003CUsingTask TaskName=\u0022Microsoft.NET.Build.Tasks.ProduceContentAssets\u0022\r\n             AssemblyFile=\u0022$(MicrosoftNETBuildTasksAssembly)\u0022 /\u003E\r\n\r\n  \u003CTarget Name=\u0022RunProduceContentAssets\u0022\r\n          DependsOnTargets=\u0022ResolvePackageAssets\u0022\r\n          Condition=\u0022\u0027@(_ContentFilesToPreprocess)\u0027 != \u0027\u0027 and \u0027$(_CleaningWithoutRebuilding)\u0027 != \u0027true\u0027\u0022\u003E\r\n\r\n    \u003CProduceContentAssets\r\n      ContentFileDependencies=\u0022@(_ContentFilesToPreprocess)\u0022\r\n      ContentPreprocessorValues=\u0022@(PreprocessorValue)\u0022\r\n      ContentPreprocessorOutputDirectory=\u0022$(ContentPreprocessorOutputDirectory)\u0022\r\n      ProduceOnlyPreprocessorFiles=\u0022true\u0022\r\n      ProjectLanguage=\u0022$(Language)\u0022\u003E\r\n\r\n      \u003COutput TaskParameter=\u0022CopyLocalItems\u0022 ItemName=\u0022_ContentCopyLocalItems\u0022 /\u003E\r\n      \u003COutput TaskParameter=\u0022ProcessedContentItems\u0022 ItemName=\u0022_ProcessedContentItems\u0022 /\u003E\r\n      \u003COutput TaskParameter=\u0022ProcessedContentItems\u0022 ItemName=\u0022FileWrites\u0022 /\u003E\r\n    \u003C/ProduceContentAssets\u003E\r\n\r\n    \u003C!-- The items in _ProcessedContentItems need to go into the appropriately-named item group,\r\n         but the names depend upon the items themselves. Split it apart. --\u003E\r\n    \u003CCreateItem Include=\u0022@(_ProcessedContentItems)\u0022 Condition=\u0022\u0027@(_ProcessedContentItems)\u0027 != \u0027\u0027\u0022\u003E\r\n      \u003COutput TaskParameter=\u0022Include\u0022 ItemName=\u0022%(_ProcessedContentItems.ProcessedItemType)\u0022 /\u003E\r\n    \u003C/CreateItem\u003E\r\n  \u003C/Target\u003E\r\n\r\n  \u003C!--\r\n    ============================================================\r\n    Reference Targets: For populating References based on lock file\r\n    - ResolveLockFileReferences\r\n    ============================================================\r\n    --\u003E\r\n\r\n  \u003CTarget Name=\u0022ResolveLockFileReferences\u0022\r\n          DependsOnTargets=\u0022ResolvePackageAssets\u0022\u003E\r\n\r\n    \u003CItemGroup Condition=\u0022\u0027$(MarkPackageReferencesAsExternallyResolved)\u0027 == \u0027true\u0027\u0022\u003E\r\n      \u003C!--\r\n        Update Reference items with NuGetPackageId metadata to set ExternallyResolved appropriately.\r\n        NetStandard.Library adds its assets in targets this way and not in the standard way that\r\n        would get ExternallyResolved set in ResolvePackageAssets.\r\n       --\u003E\r\n      \u003CReference Condition=\u0022\u0027%(Reference.NuGetPackageId)\u0027 != \u0027\u0027\u0022\u003E\r\n        \u003CExternallyResolved\u003Etrue\u003C/ExternallyResolved\u003E\r\n      \u003C/Reference\u003E\r\n\r\n      \u003C!-- Add framework references from NuGet packages here, so that if there is also a matching reference from a NuGet package,\r\n           it will be treated the same as a reference from the project file.  If there is already an explicit Reference from the\r\n           project, use that, in order to preserve metadata (such as aliases). --\u003E\r\n      \u003CReference Include=\u0022@(ResolvedFrameworkAssemblies)\u0022\r\n                 Exclude=\u0022@(Reference)\u0022 /\u003E\r\n\r\n    \u003C/ItemGroup\u003E\r\n\r\n    \u003C!-- If there are any references from a NuGet package that match a simple reference which\r\n         would resolve to a framework assembly, then update the NuGet references to use the\r\n         simple name as the ItemSpec.  This will prevent the VS project system from marking\r\n         a reference with a warning.  See https://github.com/dotnet/sdk/issues/1499 --\u003E\r\n    \u003CJoinItems Left=\u0022@(ResolvedCompileFileDefinitions)\u0022 LeftKey=\u0022FileName\u0022 LeftMetadata=\u0022*\u0022\r\n               Right=\u0022@(Reference)\u0022 RightKey=\u0022\u0022 RightMetadata=\u0022*\u0022\u003E\r\n      \u003COutput TaskParameter=\u0022JoinResult\u0022 ItemName=\u0022_JoinedResolvedCompileFileDefinitions\u0022 /\u003E\r\n    \u003C/JoinItems\u003E\r\n\r\n    \u003CItemGroup\u003E\r\n      \u003CReference Remove=\u0022@(_JoinedResolvedCompileFileDefinitions)\u0022 /\u003E\r\n      \u003CReference Include=\u0022@(_JoinedResolvedCompileFileDefinitions)\u0022 /\u003E\r\n    \u003C/ItemGroup\u003E\r\n\r\n    \u003CItemGroup\u003E\r\n      \u003CResolvedCompileFileDefinitionsToAdd Include=\u0022@(ResolvedCompileFileDefinitions)\u0022 /\u003E\r\n      \u003CResolvedCompileFileDefinitionsToAdd Remove=\u0022%(_JoinedResolvedCompileFileDefinitions.HintPath)\u0022 /\u003E\r\n\r\n      \u003C!-- Add the references we computed --\u003E\r\n      \u003CReference Include=\u0022@(ResolvedCompileFileDefinitionsToAdd)\u0022 /\u003E\r\n    \u003C/ItemGroup\u003E\r\n\r\n  \u003C/Target\u003E\r\n\r\n  \u003C!--\r\n    ============================================================\r\n    ProjectReference Targets: Include transitive project references before\r\n                              ResolveProjectReferences is called\r\n    - IncludeTransitiveProjectReferences\r\n    ============================================================\r\n    --\u003E\r\n\r\n  \u003CTarget Name=\u0022IncludeTransitiveProjectReferences\u0022\r\n          DependsOnTargets=\u0022ResolvePackageAssets\u0022\r\n          Condition=\u0022\u0027$(DisableTransitiveProjectReferences)\u0027 != \u0027true\u0027\u0022\u003E\r\n    \u003CItemGroup\u003E\r\n      \u003CProjectReference Include=\u0022@(_TransitiveProjectReferences)\u0022 /\u003E\r\n    \u003C/ItemGroup\u003E\r\n  \u003C/Target\u003E\r\n\r\n  \u003C!--\r\n    ============================================================\r\n    Analyzer Targets: For populating Analyzers based on lock file\r\n    - ResolveLockFileAnalyzers\r\n    ============================================================\r\n    --\u003E\r\n  \u003CTarget Name=\u0022ResolveLockFileAnalyzers\u0022\r\n          DependsOnTargets=\u0022ResolvePackageAssets\u0022\u003E\r\n    \u003CItemGroup\u003E\r\n      \u003CAnalyzer Include=\u0022@(ResolvedAnalyzers)\u0022 /\u003E\r\n    \u003C/ItemGroup\u003E\r\n  \u003C/Target\u003E\r\n\r\n  \u003C!--\r\n    ============================================================\r\n    ResolveLockFileCopyLocalFiles\r\n    Resolves the files from the assets file to copy for build and publish.\r\n    ============================================================\r\n  --\u003E\r\n  \u003CTarget Name=\u0022ResolveLockFileCopyLocalFiles\u0022\r\n          DependsOnTargets=\u0022ResolvePackageAssets;RunProduceContentAssets\u0022\u003E\r\n\r\n    \u003CItemGroup\u003E\r\n      \u003C_ResolvedCopyLocalBuildAssets Include=\u0022@(RuntimeCopyLocalItems)\u0022\r\n                                     Condition=\u0022\u0027%(RuntimeCopyLocalItems.CopyLocal)\u0027 == \u0027true\u0027\u0022 /\u003E\r\n      \u003C_ResolvedCopyLocalBuildAssets Include=\u0022@(ResourceCopyLocalItems)\u0022\r\n                                     Condition=\u0022\u0027%(ResourceCopyLocalItems.CopyLocal)\u0027 == \u0027true\u0027\u0022 /\u003E\r\n      \u003C!-- Always exclude the apphost executable from copy local assets; we will copy the generated apphost instead. --\u003E\r\n      \u003C_ResolvedCopyLocalBuildAssets Include=\u0022@(NativeCopyLocalItems)\u0022\r\n                                     Exclude=\u0022@(_NativeRestoredAppHostNETCore)\u0022\r\n                                     Condition=\u0022\u0027%(NativeCopyLocalItems.CopyLocal)\u0027 == \u0027true\u0027\u0022 /\u003E\r\n      \u003C_ResolvedCopyLocalBuildAssets Include=\u0022@(RuntimeTargetsCopyLocalItems)\u0022\r\n                                     Condition=\u0022\u0027%(RuntimeTargetsCopyLocalItems.CopyLocal)\u0027 == \u0027true\u0027\u0022 /\u003E\r\n\r\n      \u003CReferenceCopyLocalPaths Include=\u0022@(_ContentCopyLocalItems)\u0022 /\u003E\r\n      \u003CReferenceCopyLocalPaths Include=\u0022@(_ResolvedCopyLocalBuildAssets)\u0022\r\n                               Condition=\u0022\u0027$(CopyLocalLockFileAssemblies)\u0027 == \u0027true\u0027\u0022 /\u003E\r\n    \u003C/ItemGroup\u003E\r\n\r\n  \u003C/Target\u003E\r\n\r\n  \u003C!-- Override EnsureNETCoreAppRuntime target which is included in Microsoft.NETCore.App NuGet package for\r\n       .NET Core 2.x.  It no longer works with the .NET 5.0.100 SDK, as the ParentTarget metadata has changed format\r\n       but the targets in the NuGet package still expect the old format.\r\n\r\n       So here we just override that target.  We have logic in the SDK that covers this scenario and generates\r\n       NETSDK1056. --\u003E\r\n  \u003CTarget Name=\u0022EnsureNETCoreAppRuntime\u0022 /\u003E\r\n\r\n\u003C/Project\u003E\r\n","Selections":[{"Caret":14260,"Start":0,"End":28372}],"FilePath":"C:\\Program Files\\dotnet\\sdk\\7.0.401\\Sdks\\Microsoft.NET.Sdk\\targets\\Microsoft.PackageDependencyResolution.targets","Language":null}],"PreSelectedSkill":null,"CorrelationId":{"Guid":"b3e9ce7d-8f80-4d53-b6a1-45de9c4aa949"}}},"Response":{"Content":"\u003CTarget Name=\u0022_ResolveCompilerVersion\u0022\n          Condition=\u0022\u0027$(CompilerApiVersion)\u0027 == \u0027\u0027 And\n                     (\u0027$(Language)\u0027 == \u0027C#\u0027 Or \u0027$(Language)\u0027 == \u0027VB\u0027) And\n                     Exists(\u0027$(RoslynTargetsPath)\\Microsoft.Build.Tasks.CodeAnalysis.dll\u0027)\u0022\u003E\n    \n    \u003CGetAssemblyIdentity AssemblyFiles=\u0022$(RoslynTargetsPath)\\Microsoft.Build.Tasks.CodeAnalysis.dll\u0022\u003E\n      \u003COutput TaskParameter=\u0022Assemblies\u0022 ItemName=\u0022_CodeAnalysisIdentity\u0022 /\u003E\n    \u003C/GetAssemblyIdentity\u003E\n\n    \u003CPropertyGroup\u003E\n      \u003C_RoslynApiVersion\u003E$([System.Version]::Parse(%(_CodeAnalysisIdentity.Version)).Major).$([System.Version]::Parse(%(_CodeAnalysisIdentity.Version)).Minor)\u003C/_RoslynApiVersion\u003E\n      \u003CCompilerApiVersion\u003Eroslyn$(_RoslynApiVersion)\u003C/CompilerApiVersion\u003E\n    \u003C/PropertyGroup\u003E\n    \n  \u003C/Target\u003E\n\n  \u003CTarget Name=\u0022ResolvePackageAssets\u0022\n          Condition=\u0022(\u0027$(DesignTimeBuild)\u0027 != \u0027true\u0027 Or Exists(\u0027$(ProjectAssetsFile)\u0027)) And \u0027$(SkipResolvePackageAssets)\u0027 != \u0027true\u0027\u0022\n          DependsOnTargets=\u0022ProcessFrameworkReferences;_DefaultMicrosoftNETPlatformLibrary;_ComputePackageReferencePublish;_ResolveCompilerVersion\u0022\u003E\n\n    \u003CPropertyGroup Condition=\u0022\u0027$(TargetFrameworkIdentifier)\u0027 == \u0027.NETCoreApp\u0027\n                          and \u0027$(_TargetFrameworkVersionWithoutV)\u0027 \u003E= \u00273.0\u0027\n                          and \u0027$(UseAppHostFromAssetsFile)\u0027 == \u0027\u0027\u0022\u003E\n      \u003C!-- For .NET Core 3.0 and higher, we\u0027ll get the apphost from an apphost pack (via ProcessFrameworkReferences) --\u003E\n      \u003CUseAppHostFromAssetsFile\u003Efalse\u003C/UseAppHostFromAssetsFile\u003E\n    \u003C/PropertyGroup\u003E\n    \u003CPropertyGroup Condition=\u0022\u0027$(UseAppHostFromAssetsFile)\u0027 == \u0027\u0027\u0022\u003E\n      \u003CUseAppHostFromAssetsFile\u003Etrue\u003C/UseAppHostFromAssetsFile\u003E\n    \u003C/PropertyGroup\u003E\n\n    \u003CPropertyGroup Condition=\u0022\u0027$(EnsureRuntimePackageDependencies)\u0027 == \u0027\u0027\n                          and \u0027$(TargetFrameworkIdentifier)\u0027 == \u0027.NETCoreApp\u0027\n                          and \u0027$(_TargetFrameworkVersionWithoutV)\u0027 \u0026lt; \u00273.0\u0027\n                          and \u0027$(EnsureNETCoreAppRuntime)\u0027 != \u0027false\u0027\u0022\u003E\n      \u003CEnsureRuntimePackageDependencies\u003Etrue\u003C/EnsureRuntimePackageDependencies\u003E\n    \u003C/PropertyGroup\u003E\n\n    \u003C!-- Only copy local runtime target assets if targeting netcoreapp --\u003E\n    \u003CPropertyGroup Condition=\u0022\u0027$(CopyLocalRuntimeTargetAssets)\u0027 == \u0027\u0027 and \u0027$(TargetFrameworkIdentifier)\u0027 == \u0027.NETCoreApp\u0027\u0022\u003E\n      \u003CCopyLocalRuntimeTargetAssets\u003Etrue\u003C/CopyLocalRuntimeTargetAssets\u003E\n    \u003C/PropertyGroup\u003E\n\n    \u003CItemGroup\u003E\n      \u003C_PackAsToolShimRuntimeIdentifiers Condition=\u0022@(_PackAsToolShimRuntimeIdentifiers) ==\u0027\u0027\u0022 Include=\u0022$(PackAsToolShimRuntimeIdentifiers)\u0022/\u003E\n\n      \u003C!-- Pass these packages into the ResolvePackageAssets task to verify that the restored versions of the packages\n           match the expected version --\u003E\n      \u003CExpectedPlatformPackages Include=\u0022@(PackageReference)\u0022 Condition=\u0022\u0027%(Identity)\u0027 == \u0027Microsoft.NETCore.App\u0027\u0022 /\u003E\n      \u003CExpectedPlatformPackages Include=\u0022@(PackageReference)\u0022 Condition=\u0022\u0027%(Identity)\u0027 == \u0027Microsoft.AspNetCore.App\u0027\u0022 /\u003E\n      \u003CExpectedPlatformPackages Include=\u0022@(PackageReference)\u0022 Condition=\u0022\u0027%(Identity)\u0027 == \u0027Microsoft.AspNetCore.All\u0027\u0022 /\u003E\n    \u003C/ItemGroup\u003E\n[CURRENT LINE WITH CURSOR]\n    \u003CResolvePackageAssets\n      ProjectAssetsFile=\u0022$(ProjectAssetsFile)\u0022\n      ProjectAssetsCacheFile=\u0022$(ProjectAssetsCacheFile)\u0022\n      ProjectPath=\u0022$(MSBuildProjectFullPath)\u0022\n      ProjectLanguage=\u0022$(Language)\u0022\n      CompilerApiVersion=\u0022$(CompilerApiVersion)\u0022\n      EmitAssetsLogMessages=\u0022$(EmitAssetsLogMessages)\u0022\n      TargetFramework=\u0022$(TargetFramework)\u0022\n      RuntimeIdentifier=\u0022$(RuntimeIdentifier)\u0022\n      PlatformLibraryName=\u0022$(MicrosoftNETPlatformLibrary)\u0022\n      RuntimeFrameworks=\u0022@(RuntimeFramework)\u0022\n      IsSelfContained=\u0022$(SelfContained)\u0022\n      MarkPackageReferencesAsExternallyResolved=\u0022$(MarkPackageReferencesAsExternallyResolved)\u0022\n      DisablePackageAssetsCache=\u0022$(DisablePackageAssetsCache)\u0022\n      DisableFrameworkAssemblies=\u0022$(DisableLockFileFrameworks)\u0022\n      CopyLocalRuntimeTargetAssets=\u0022$(CopyLocalRuntimeTargetAssets)\u0022\n      DisableTransitiveProjectReferences=\u0022$(DisableTransitiveProjectReferences)\u0022\n      DisableTransitiveFrameworkReferences=\u0022$(DisableTransitiveFrameworkReferences)\u0022\n      DotNetAppHostExecutableNameWithoutExtension=\u0022$(_DotNetAppHostExecutableNameWithoutExtension)\u0022\n      ShimRuntimeIdentifiers=\u0022@(_PackAsToolShimRuntimeIdentifiers)\u0022\n      EnsureRuntimePackageDependencies=\u0022$(EnsureRuntimePackageDependencies)\u0022\n      VerifyMatchingImplicitPackageVersion=\u0022$(VerifyMatchingImplicitPackageVersion)\u0022\n      ExpectedPlatformPackages=\u0022@(ExpectedPlatformPackages)\u0022\n      SatelliteResourceLanguages=\u0022$(SatelliteResourceLanguages)\u0022\n      DesignTimeBuild=\u0022$(DesignTimeBuild)\u0022\n      ContinueOnError=\u0022$(ContinueOnError)\u0022\n      PackageReferences=\u0022@(PackageReference)\u0022\u003E\n\n      \u003C!-- NOTE: items names here are inconsistent because they match prior implementation\n          (that was spread across different tasks/targets) for backwards compatibility.  --\u003E\n      \u003COutput TaskParameter=\u0022Analyzers\u0022 ItemName=\u0022ResolvedAnalyzers\u0022 /\u003E\n      \u003COutput TaskParameter=\u0022ApphostsForShimRuntimeIdentifiers\u0022 ItemName=\u0022_ApphostsForShimRuntimeIdentifiersResolvePackageAssets\u0022 /\u003E\n      \u003COutput TaskParameter=\u0022ContentFilesToPreprocess\u0022 ItemName=\u0022_ContentFilesToPreprocess\u0022 /\u003E\n      \u003COutput TaskParameter=\u0022DebugSymbolsFiles\u0022 ItemName=\u0022_DebugSymbolsFiles\u0022 /\u003E\n      \u003COutput TaskParameter=\u0022ReferenceDocumentationFiles\u0022 ItemName=\u0022_ReferenceDocumentationFiles\u0022 /\u003E\n      \u003COutput TaskParameter=\u0022FrameworkAssemblies\u0022 ItemName=\u0022ResolvedFrameworkAssemblies\u0022 /\u003E\n      \u003COutput TaskParameter=\u0022FrameworkReferences\u0022 ItemName=\u0022TransitiveFrameworkReference\u0022 /\u003E\n      \u003COutput TaskParameter=\u0022NativeLibraries\u0022 ItemName=\u0022NativeCopyLocalItems\u0022 /\u003E\n      \u003COutput TaskParameter=\u0022ResourceAssemblies\u0022 ItemName=\u0022ResourceCopyLocalItems\u0022 /\u003E\n      \u003COutput TaskParameter=\u0022RuntimeAssemblies\u0022 ItemName=\u0022RuntimeCopyLocalItems\u0022 /\u003E\n      \u003COutput TaskParameter=\u0022RuntimeTargets\u0022 ItemName=\u0022RuntimeTargetsCopyLocalItems\u0022 /\u003E\n      \u003COutput TaskParameter=\u0022CompileTimeAssemblies\u0022 ItemName=\u0022ResolvedCompileFileDefinitions\u0022 /\u003E\n      \u003COutput TaskParameter=\u0022TransitiveProjectReferences\u0022 ItemName=\u0022_TransitiveProjectReferences\u0022 /\u003E\n      \u003COutput TaskParameter=\u0022PackageFolders\u0022 ItemName=\u0022AssetsFilePackageFolder\u0022 /\u003E\n      \u003COutput TaskParameter=\u0022PackageDependencies\u0022 ItemName=\u0022PackageDependencies\u0022 /\u003E\n      \u003COutput TaskParameter=\u0022PackageDependenciesDesignTime\u0022 ItemName=\u0022_PackageDependenciesDesignTime\u0022 /\u003E\n    \u003C/ResolvePackageAssets\u003E\n\n    \u003CItemGroup Condition=\u0022\u0027$(CopyDebugSymbolFilesFromPackages)\u0027 == \u0027true\u0027\u0022\u003E\n\u003C/ItemGroup\u003E\n[CURRENT DOCUMENT CODE SELECTED BY THE DEVELOPER END]","Type":1,"Status":1,"FollowUpPrompts":null},"SelectedFunctionName":"Fix","LoggedSkillInvocations":null}
{"version":1,"Request":{"Prompt":"write git ignore file to ignore bin and obj folders","Context":{"VisibleDocuments":[{"Content":"\u003C!--\r\n***********************************************************************************************\r\nXamarin.Android.Aapt2.targets\r\n\r\nWARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have\r\n  created a backup copy.  Incorrect changes to this file will make it\r\n  impossible to load or build your projects from the command-line or the IDE.\r\n\r\nThis file imports the version- and platform-specific targets for the project importing\r\nthis file. This file also defines targets to produce an error if the specified targets\r\nfile does not exist, but the project is built anyway (command-line or IDE build).\r\n\r\nCopyright (C) 2010-2011 Novell. All rights reserved.\r\nCopyright (C) 2011-2012 Xamarin. All rights reserved.\r\n***********************************************************************************************\r\n--\u003E\r\n\r\n\u003CProject xmlns=\u0022http://schemas.microsoft.com/developer/msbuild/2003\u0022\u003E\r\n\r\n\u003CUsingTask TaskName=\u0022Xamarin.Android.Tasks.Aapt2Compile\u0022 AssemblyFile=\u0022Xamarin.Android.Build.Tasks.dll\u0022 /\u003E\r\n\u003CUsingTask TaskName=\u0022Xamarin.Android.Tasks.Aapt2Link\u0022 AssemblyFile=\u0022Xamarin.Android.Build.Tasks.dll\u0022 /\u003E\r\n\r\n\u003CPropertyGroup\u003E\r\n  \u003CAapt2DaemonMaxInstanceCount Condition=\u0022 \u0027$(Aapt2DaemonMaxInstanceCount)\u0027 == \u0027\u0027 \u0022 \u003E0\u003C/Aapt2DaemonMaxInstanceCount\u003E\r\n  \u003C_Aapt2DaemonKeepInDomain Condition=\u0022 \u0027$(_Aapt2DaemonKeepInDomain)\u0027 == \u0027\u0027 \u0022\u003Efalse\u003C/_Aapt2DaemonKeepInDomain\u003E\r\n\u003C/PropertyGroup\u003E\r\n\r\n\r\n\u003CTarget Name=\u0022_InjectAaptDependencies\u0022\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003C_SetLatestTargetFrameworkVersionDependsOnTargets\u003E\r\n      $(_SetLatestTargetFrameworkVersionDependsOnTargets);\r\n      _CreateAapt2VersionCache;\r\n    \u003C/_SetLatestTargetFrameworkVersionDependsOnTargets\u003E\r\n    \u003C_PrepareUpdateAndroidResgenDependsOnTargets\u003E\r\n      _CompileResources;\r\n      _Aapt2UpdateAndroidResgenInputs;\r\n      $(_PrepareUpdateAndroidResgenDependsOnTargets);\r\n    \u003C/_PrepareUpdateAndroidResgenDependsOnTargets\u003E\r\n    \u003C_AfterConvertCustomView\u003E\r\n      $(_AfterConvertCustomView);\r\n      _FixupCustomViewsForAapt2;\r\n    \u003C/_AfterConvertCustomView\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\u003C/Target\u003E\r\n\r\n\u003CTarget Name=\u0022_ReadAapt2VersionCache\u0022\u003E\r\n  \u003CReadLinesFromFile File=\u0022$(_AndroidAapt2VersionFile)\u0022\r\n      Condition=\u0022Exists(\u0027$(_AndroidAapt2VersionFile)\u0027)\u0022\u003E\r\n    \u003COutput TaskParameter=\u0022Lines\u0022 ItemName=\u0022_Aapt2VersionCache\u0022/\u003E\r\n  \u003C/ReadLinesFromFile\u003E\r\n\u003C/Target\u003E\r\n\r\n\u003CTarget Name=\u0022_CreateAapt2VersionCache\u0022\r\n    Condition=\u0022 \u0027$(_Aapt2Version)\u0027 != \u0027@(_Aapt2VersionCache)\u0027 \u0022\r\n    DependsOnTargets=\u0022_ReadAapt2VersionCache\u0022\r\n  \u003E\r\n  \u003CMakeDir Directories=\u0022$(IntermediateOutputPath)\u0022 Condition=\u0022!Exists(\u0027$(IntermediateOutputPath)\u0027)\u0022 /\u003E\r\n  \u003CWriteLinesToFile\r\n      Condition=\u0022 \u0027$(_Aapt2Version)\u0027 != \u0027@(_Aapt2VersionCache)\u0027 \u0022\r\n      File=\u0022$(_AndroidAapt2VersionFile)\u0022\r\n      Lines=\u0022$(_Aapt2Version)\u0022\r\n      Overwrite=\u0022true\u0022\r\n  /\u003E\r\n  \u003CItemGroup Condition=\u0022\u0027$(_Aapt2Version)\u0027 != \u0027@(_Aapt2VersionCache)\u0027\u0022\u003E\r\n    \u003C_CompiledFlataArchive Include=\u0022$(_AndroidLibrayProjectIntermediatePath)**\\*.flata\u0022 /\u003E\r\n    \u003C_CompiledFlataArchive Include=\u0022$(_AndroidLibrayProjectIntermediatePath)**\\*.flat\u0022 /\u003E\r\n    \u003C_CompiledFlataArchive Include=\u0022$(_AndroidLibraryFlatFilesDirectory)*.flat\u0022 /\u003E\r\n    \u003C_CompiledFlataArchive Include=\u0022$(_AndroidLibraryFlatArchivesDirectory)\\*.flata\u0022 /\u003E\r\n    \u003C_CompiledFlataStamp Include=\u0022$(_AndroidLibrayProjectIntermediatePath)**\\compiled.stamp\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n  \u003CDelete\r\n      Condition=\u0022\u0027$(_Aapt2Version)\u0027 != \u0027@(_Aapt2VersionCache)\u0027\u0022\r\n      Files=\u0022@(_CompiledFlataArchive);@(_CompiledFlataStamp)\u0022\r\n  /\u003E\r\n\u003C/Target\u003E\r\n\r\n\u003CTarget Name=\u0022_CollectLibraryResourceDirectories\u0022\u003E\r\n  \u003CCollectNonEmptyDirectories\r\n      Directories=\u0022@(LibraryResourceDirectories)\u0022\r\n      LibraryProjectIntermediatePath=\u0022$(_AndroidLibrayProjectIntermediatePath)\u0022\r\n      StampDirectory=\u0022$(_AndroidStampDirectory)\u0022\u003E\r\n    \u003COutput TaskParameter=\u0022Output\u0022 ItemName=\u0022_LibraryResourceDirectories\u0022 /\u003E\r\n    \u003COutput TaskParameter=\u0022LibraryResourceFiles\u0022 ItemName=\u0022_LibraryResourceFiles\u0022 /\u003E\r\n    \u003COutput TaskParameter=\u0022LibraryResourceFiles\u0022 ItemName=\u0022_CompileResourcesInputs\u0022 /\u003E\r\n  \u003C/CollectNonEmptyDirectories\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CFileWrites Include=\u0022@(_LibraryResourceDirectories-\u003E\u0027%(FilesCache)\u0027)\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n\u003C/Target\u003E\r\n\r\n\u003CTarget Name=\u0022_ConvertResourcesCases\u0022\r\n    Inputs=\u0022@(_AndroidMSBuildAllProjects);$(_AndroidBuildPropertiesCache);@(AndroidResource);@(_LibraryResourceDirectories-\u003E\u0027%(StampFile)\u0027)\u0022\r\n    Outputs=\u0022$(_AndroidStampDirectory)_ConvertResourcesCases.stamp\u0022\r\n    DependsOnTargets=\u0022_CollectLibraryResourceDirectories;$(_BeforeConvertResourcesCases)\u0022\r\n  \u003E\r\n  \u003CMakeDir Directories=\u0022$(_AndroidLibraryFlatArchivesDirectory)\u0022 Condition=\u0022!Exists(\u0027$(_AndroidLibraryFlatArchivesDirectory)\u0027)\u0022 /\u003E\r\n  \u003CMakeDir Directories=\u0022$(_AndroidLibraryFlatFilesDirectory)\u0022 Condition=\u0022!Exists(\u0027$(_AndroidLibraryFlatFilesDirectory)\u0027)\u0022 /\u003E\r\n  \u003C!-- Change cases so we support mixed case resource names --\u003E\r\n  \u003CConvertResourcesCases\r\n      ContinueOnError=\u0022$(DesignTimeBuild)\u0022\r\n      AndroidConversionFlagFile=\u0022$(_AndroidStampDirectory)_ConvertResourcesCases.stamp\u0022\r\n      CustomViewMapFile=\u0022$(_CustomViewMapFile)\u0022\r\n      ResourceDirectories=\u0022$(MonoAndroidResDirIntermediate);@(_LibraryResourceDirectories)\u0022\r\n  /\u003E\r\n  \u003CTouch Files=\u0022$(_AndroidStampDirectory)_ConvertResourcesCases.stamp\u0022 AlwaysCreate=\u0022True\u0022 /\u003E\r\n\u003C/Target\u003E\r\n\r\n\u003CTarget Name=\u0022_CalculateResourceFileName\u0022\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003C_CompileResourcesInputs Include=\u0022@(_AndroidResourceDest)\u0022\u003E\r\n      \u003CStampFile\u003E%(Identity)\u003C/StampFile\u003E\r\n    \u003C/_CompileResourcesInputs\u003E\r\n    \u003C_CompiledFlatFiles Include=\u0022@(_CompileResourcesInputs-\u003E\u0027%(_ArchiveDirectory)%(_FlatFile)\u0027)\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n\u003C/Target\u003E\r\n\r\n\u003CTarget Name=\u0022_CompileResources\u0022\r\n    Inputs=\u0022@(_AndroidMSBuildAllProjects);$(_AndroidBuildPropertiesCache);@(_CompileResourcesInputs)\u0022\r\n    Outputs=\u0022@(_CompileResourcesInputs-\u003E\u0027%(_ArchiveDirectory)%(_FlatFile)\u0027)\u0022\r\n    DependsOnTargets=\u0022$(_BeforeCompileResources);_ConvertResourcesCases;_CalculateResourceFileName\u0022\r\n  \u003E\r\n  \u003CAapt2Compile\r\n      ContinueOnError=\u0022$(DesignTimeBuild)\u0022\r\n      DaemonMaxInstanceCount=\u0022$(Aapt2DaemonMaxInstanceCount)\u0022\r\n      DaemonKeepInDomain=\u0022$(_Aapt2DaemonKeepInDomain)\u0022\r\n      ExtraArgs=\u0022$(AndroidAapt2CompileExtraArgs)\u0022\r\n      FlatFilesDirectory=\u0022$(_AndroidLibraryFlatFilesDirectory)\u0022\r\n      FlatArchivesDirectory=\u0022$(_AndroidLibraryFlatArchivesDirectory)\u0022\r\n      ResourcesToCompile=\u0022@(_CompileResourcesInputs)\u0022\r\n      ResourceDirectories=\u0022$(MonoAndroidResDirIntermediate)\u0022\r\n      ToolPath=\u0022$(Aapt2ToolPath)\u0022\r\n      ToolExe=\u0022$(Aapt2ToolExe)\u0022\r\n  /\u003E\r\n\u003C/Target\u003E\r\n\r\n\u003CTarget Name=\u0022_Aapt2UpdateAndroidResgenInputs\u0022\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003C_UpdateAndroidResgenInputs\u003E\r\n      $(_UpdateAndroidResgenInputs);\r\n      @(_CompiledFlatFiles);\r\n      @(_LibraryResourceDirectoryStamps);\r\n    \u003C/_UpdateAndroidResgenInputs\u003E\r\n    \u003C_CreateBaseApkInputs\u003E\r\n      $(_CreateBaseApkInputs);\r\n      @(_CompiledFlatFiles);\r\n      @(_LibraryResourceDirectoryStamps);\r\n    \u003C/_CreateBaseApkInputs\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\u003C/Target\u003E\r\n\r\n\u003CTarget Name=\u0022_UpdateAndroidResgenAapt2\u0022\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003CAndroidAapt2LinkExtraArgs Condition=\u0022 $(AndroidResgenExtraArgs.Contains(\u0027--no-version-vectors\u0027)) And !($(AndroidAapt2LinkExtraArgs.Contains(\u0027--no-version-vectors\u0027))) \u0022\u003E--no-version-vectors $(AndroidAapt2LinkExtraArgs) \u003C/AndroidAapt2LinkExtraArgs\u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CAapt2Link\r\n      Condition=\u0022 \u0027$(_AndroidResourceDesignerFile)\u0027 != \u0027\u0027 \u0022\r\n      ContinueOnError=\u0022$(DesignTimeBuild)\u0022\r\n      DaemonMaxInstanceCount=\u0022$(Aapt2DaemonMaxInstanceCount)\u0022\r\n      DaemonKeepInDomain=\u0022$(_Aapt2DaemonKeepInDomain)\u0022\r\n      AssemblyIdentityMapFile=\u0022$(_AndroidLibrayProjectAssemblyMapFile)\u0022\r\n      ImportsDirectory=\u0022$(_LibraryProjectImportsDirectoryName)\u0022\r\n      OutputImportDirectory=\u0022$(_AndroidLibrayProjectIntermediatePath)\u0022\r\n      OutputFile=\u0022$(ResgenTemporaryDirectory)\\resources.apk\u0022\r\n      PackageName=\u0022$(_AndroidPackage)\u0022\r\n      JavaPlatformJarPath=\u0022$(JavaPlatformJarPath)\u0022\r\n      JavaDesignerOutputDirectory=\u0022$(ResgenTemporaryDirectory)\u0022\r\n      CompiledResourceFlatFiles=\u0022@(_CompiledFlatFiles)\u0022\r\n      ManifestFiles=\u0022$(ResgenTemporaryDirectory)\\AndroidManifest.xml\u0022\r\n      AdditionalAndroidResourcePaths=\u0022@(_LibraryResourceDirectories)\u0022\r\n      YieldDuringToolExecution=\u0022$(YieldDuringToolExecution)\u0022\r\n      ResourceSymbolsTextFile=\u0022$(IntermediateOutputPath)R.txt\u0022\r\n      ResourceDirectories=\u0022$(MonoAndroidResDirIntermediate)\u0022\r\n      ExtraArgs=\u0022$(AndroidAapt2LinkExtraArgs)\u0022\r\n      ToolPath=\u0022$(Aapt2ToolPath)\u0022\r\n      ToolExe=\u0022$(Aapt2ToolExe)\u0022\r\n      UncompressedFileExtensions=\u0022$(AndroidStoreUncompressedFileExtensions)\u0022\r\n  /\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CFileWrites Include=\u0022$(IntermediateOutputPath)R.txt\u0022 Condition=\u0022 Exists (\u0027$(IntermediateOutputPath)R.txt\u0027) \u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n\u003C/Target\u003E\r\n\r\n\u003CTarget Name=\u0022_FixupCustomViewsForAapt2\u0022\r\n    Condition=\u0022 \u0027@(_ProcessedCustomViews-\u003ECount())\u0027 != \u00270\u0027 \u0022\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003C_ItemsToFixup Include=\u0022@(_CompileResourcesInputs)\u0022 Condition=\u0022 \u0027@(_ProcessedCustomViews-\u003E\u0027%(Identity)\u0027)\u0027 == \u0027%(Identity)\u0027 \u0022/\u003E\r\n  \u003C/ItemGroup\u003E\r\n  \u003CAapt2Compile\r\n      Condition=\u0022 \u0027@(_ItemsToFixup-\u003ECount())\u0027 != \u00270\u0027 \u0022\r\n      ContinueOnError=\u0022$(DesignTimeBuild)\u0022\r\n      DaemonMaxInstanceCount=\u0022$(Aapt2DaemonMaxInstanceCount)\u0022\r\n      DaemonKeepInDomain=\u0022$(_Aapt2DaemonKeepInDomain)\u0022\r\n      ResourcesToCompile=\u0022@(_ItemsToFixup)\u0022\r\n      ResourceDirectories=\u0022$(MonoAndroidResDirIntermediate);@(_LibraryResourceDirectories)\u0022\r\n      ExtraArgs=\u0022$(AndroidAapt2CompileExtraArgs)\u0022\r\n      FlatFilesDirectory=\u0022$(_AndroidLibraryFlatFilesDirectory)\u0022\r\n      FlatArchivesDirectory=\u0022$(_AndroidLibraryFlatArchivesDirectory)\u0022\r\n      ToolPath=\u0022$(Aapt2ToolPath)\u0022\r\n      ToolExe=\u0022$(Aapt2ToolExe)\u0022\u003E\r\n    \u003COutput TaskParameter=\u0022CompiledResourceFlatFiles\u0022 ItemName=\u0022_UpdatedFlatFiles\u0022 /\u003E\r\n  \u003C/Aapt2Compile\u003E\r\n  \u003CTouch Files=\u0022$(_AndroidResgenFlagFile)\u0022 AlwaysCreate=\u0022True\u0022 Condition=\u0022 \u0027@(_UpdatedFlatFiles-\u003ECount())\u0027 != \u00270\u0027 \u0022 /\u003E\r\n\u003C/Target\u003E\r\n\r\n\u003CTarget Name=\u0022_CreateBaseApkWithAapt2\u0022\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003C_ProtobufFormat Condition=\u0022 \u0027$(AndroidPackageFormat)\u0027 == \u0027aab\u0027 \u0022\u003ETrue\u003C/_ProtobufFormat\u003E\r\n    \u003C_ProtobufFormat Condition=\u0022 \u0027$(_ProtobufFormat)\u0027 == \u0027\u0027 \u0022\u003EFalse\u003C/_ProtobufFormat\u003E\r\n    \u003C_Aapt2ProguardRules Condition=\u0022 \u0027$(AndroidLinkTool)\u0027 != \u0027\u0027 \u0022\u003E$(IntermediateOutputPath)aapt_rules.txt\u003C/_Aapt2ProguardRules\u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CAapt2Link\r\n      AndroidManifestFile=\u0022$(_AndroidManifestAbs)\u0022\r\n      CompiledResourceFlatFiles=\u0022@(_CompiledFlatFiles)\u0022\r\n      DaemonMaxInstanceCount=\u0022$(Aapt2DaemonMaxInstanceCount)\u0022\r\n      DaemonKeepInDomain=\u0022$(_Aapt2DaemonKeepInDomain)\u0022\r\n      ResourceDirectories=\u0022$(MonoAndroidResDirIntermediate)\u0022\r\n      AssemblyIdentityMapFile=\u0022$(_AndroidLibrayProjectAssemblyMapFile)\u0022\r\n      ImportsDirectory=\u0022$(_LibraryProjectImportsDirectoryName)\u0022\r\n      OutputImportDirectory=\u0022$(_AndroidLibrayProjectIntermediatePath)\u0022\r\n      OutputFile=\u0022$(_PackagedResources)\u0022\r\n      AdditionalAndroidResourcePaths=\u0022@(_LibraryResourceDirectories)\u0022\r\n      YieldDuringToolExecution=\u0022$(YieldDuringToolExecution)\u0022\r\n      PackageName=\u0022$(_AndroidPackage)\u0022\r\n      JavaPlatformJarPath=\u0022$(JavaPlatformJarPath)\u0022\r\n      VersionCodePattern=\u0022$(AndroidVersionCodePattern)\u0022\r\n      VersionCodeProperties=\u0022$(AndroidVersionCodeProperties)\u0022\r\n      SupportedAbis=\u0022@(_BuildTargetAbis)\u0022\r\n      CreatePackagePerAbi=\u0022$(AndroidCreatePackagePerAbi)\u0022\r\n      AssetsDirectory=\u0022$(MonoAndroidAssetsDirIntermediate)\u0022\r\n      AdditionalAndroidAssetPaths=\u0022@(LibraryAssetDirectories)\u0022\r\n      AndroidSdkPlatform=\u0022$(_AndroidApiLevel)\u0022\r\n      JavaDesignerOutputDirectory=\u0022$(AaptTemporaryDirectory)\u0022\r\n      ManifestFiles=\u0022$(IntermediateOutputPath)android\\AndroidManifest.xml\u0022\r\n      ProtobufFormat=\u0022$(_ProtobufFormat)\u0022\r\n      ExtraArgs=\u0022$(AndroidAapt2LinkExtraArgs)\u0022\r\n      ToolPath=\u0022$(Aapt2ToolPath)\u0022\r\n      ToolExe=\u0022$(Aapt2ToolExe)\u0022\r\n      UncompressedFileExtensions=\u0022$(AndroidStoreUncompressedFileExtensions)\u0022\r\n      ProguardRuleOutput=\u0022$(_Aapt2ProguardRules)\u0022\r\n  /\u003E\r\n  \u003CItemGroup Condition=\u0022 \u0027$(_Aapt2ProguardRules)\u0027 != \u0027\u0027 And Exists(\u0027$(_Aapt2ProguardRules)\u0027) \u0022\u003E\r\n    \u003CProguardConfiguration Include=\u0022$(_Aapt2ProguardRules)\u0022 /\u003E\r\n    \u003CFileWrites Include=\u0022$(_Aapt2ProguardRules)\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n\u003C/Target\u003E\r\n\u003C/Project\u003E\r\n","Selections":[{"Caret":10173,"Start":0,"End":12033}],"FilePath":"C:\\Program Files\\dotnet\\packs\\Microsoft.Android.Sdk.Windows\\33.0.68\\tools\\Xamarin.Android.Aapt2.targets","Language":null}],"PreSelectedSkill":null,"CorrelationId":{"Guid":"53a7161a-ba7f-47a2-8fb3-be8a6750e6b1"}}},"Response":{"Content":"# Visual Studio / Visual Studio for Mac\n.vs/\n\n# ReSharper\n_ReSharper*/\n*/bin/\n*/obj/","Type":1,"Status":1,"FollowUpPrompts":null},"SelectedFunctionName":"Generate","LoggedSkillInvocations":null}
{"version":1,"Request":{"Prompt":"how to ignore bin folder","Context":{"VisibleDocuments":[{"Content":"\u003C!--\r\n***********************************************************************************************\r\nXamarin.Android.Aapt2.targets\r\n\r\nWARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have\r\n  created a backup copy.  Incorrect changes to this file will make it\r\n  impossible to load or build your projects from the command-line or the IDE.\r\n\r\nThis file imports the version- and platform-specific targets for the project importing\r\nthis file. This file also defines targets to produce an error if the specified targets\r\nfile does not exist, but the project is built anyway (command-line or IDE build).\r\n\r\nCopyright (C) 2010-2011 Novell. All rights reserved.\r\nCopyright (C) 2011-2012 Xamarin. All rights reserved.\r\n***********************************************************************************************\r\n--\u003E\r\n\r\n\u003CProject xmlns=\u0022http://schemas.microsoft.com/developer/msbuild/2003\u0022\u003E\r\n\r\n\u003CUsingTask TaskName=\u0022Xamarin.Android.Tasks.Aapt2Compile\u0022 AssemblyFile=\u0022Xamarin.Android.Build.Tasks.dll\u0022 /\u003E\r\n\u003CUsingTask TaskName=\u0022Xamarin.Android.Tasks.Aapt2Link\u0022 AssemblyFile=\u0022Xamarin.Android.Build.Tasks.dll\u0022 /\u003E\r\n\r\n\u003CPropertyGroup\u003E\r\n  \u003CAapt2DaemonMaxInstanceCount Condition=\u0022 \u0027$(Aapt2DaemonMaxInstanceCount)\u0027 == \u0027\u0027 \u0022 \u003E0\u003C/Aapt2DaemonMaxInstanceCount\u003E\r\n  \u003C_Aapt2DaemonKeepInDomain Condition=\u0022 \u0027$(_Aapt2DaemonKeepInDomain)\u0027 == \u0027\u0027 \u0022\u003Efalse\u003C/_Aapt2DaemonKeepInDomain\u003E\r\n\u003C/PropertyGroup\u003E\r\n\r\n\r\n\u003CTarget Name=\u0022_InjectAaptDependencies\u0022\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003C_SetLatestTargetFrameworkVersionDependsOnTargets\u003E\r\n      $(_SetLatestTargetFrameworkVersionDependsOnTargets);\r\n      _CreateAapt2VersionCache;\r\n    \u003C/_SetLatestTargetFrameworkVersionDependsOnTargets\u003E\r\n    \u003C_PrepareUpdateAndroidResgenDependsOnTargets\u003E\r\n      _CompileResources;\r\n      _Aapt2UpdateAndroidResgenInputs;\r\n      $(_PrepareUpdateAndroidResgenDependsOnTargets);\r\n    \u003C/_PrepareUpdateAndroidResgenDependsOnTargets\u003E\r\n    \u003C_AfterConvertCustomView\u003E\r\n      $(_AfterConvertCustomView);\r\n      _FixupCustomViewsForAapt2;\r\n    \u003C/_AfterConvertCustomView\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\u003C/Target\u003E\r\n\r\n\u003CTarget Name=\u0022_ReadAapt2VersionCache\u0022\u003E\r\n  \u003CReadLinesFromFile File=\u0022$(_AndroidAapt2VersionFile)\u0022\r\n      Condition=\u0022Exists(\u0027$(_AndroidAapt2VersionFile)\u0027)\u0022\u003E\r\n    \u003COutput TaskParameter=\u0022Lines\u0022 ItemName=\u0022_Aapt2VersionCache\u0022/\u003E\r\n  \u003C/ReadLinesFromFile\u003E\r\n\u003C/Target\u003E\r\n\r\n\u003CTarget Name=\u0022_CreateAapt2VersionCache\u0022\r\n    Condition=\u0022 \u0027$(_Aapt2Version)\u0027 != \u0027@(_Aapt2VersionCache)\u0027 \u0022\r\n    DependsOnTargets=\u0022_ReadAapt2VersionCache\u0022\r\n  \u003E\r\n  \u003CMakeDir Directories=\u0022$(IntermediateOutputPath)\u0022 Condition=\u0022!Exists(\u0027$(IntermediateOutputPath)\u0027)\u0022 /\u003E\r\n  \u003CWriteLinesToFile\r\n      Condition=\u0022 \u0027$(_Aapt2Version)\u0027 != \u0027@(_Aapt2VersionCache)\u0027 \u0022\r\n      File=\u0022$(_AndroidAapt2VersionFile)\u0022\r\n      Lines=\u0022$(_Aapt2Version)\u0022\r\n      Overwrite=\u0022true\u0022\r\n  /\u003E\r\n  \u003CItemGroup Condition=\u0022\u0027$(_Aapt2Version)\u0027 != \u0027@(_Aapt2VersionCache)\u0027\u0022\u003E\r\n    \u003C_CompiledFlataArchive Include=\u0022$(_AndroidLibrayProjectIntermediatePath)**\\*.flata\u0022 /\u003E\r\n    \u003C_CompiledFlataArchive Include=\u0022$(_AndroidLibrayProjectIntermediatePath)**\\*.flat\u0022 /\u003E\r\n    \u003C_CompiledFlataArchive Include=\u0022$(_AndroidLibraryFlatFilesDirectory)*.flat\u0022 /\u003E\r\n    \u003C_CompiledFlataArchive Include=\u0022$(_AndroidLibraryFlatArchivesDirectory)\\*.flata\u0022 /\u003E\r\n    \u003C_CompiledFlataStamp Include=\u0022$(_AndroidLibrayProjectIntermediatePath)**\\compiled.stamp\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n  \u003CDelete\r\n      Condition=\u0022\u0027$(_Aapt2Version)\u0027 != \u0027@(_Aapt2VersionCache)\u0027\u0022\r\n      Files=\u0022@(_CompiledFlataArchive);@(_CompiledFlataStamp)\u0022\r\n  /\u003E\r\n\u003C/Target\u003E\r\n\r\n\u003CTarget Name=\u0022_CollectLibraryResourceDirectories\u0022\u003E\r\n  \u003CCollectNonEmptyDirectories\r\n      Directories=\u0022@(LibraryResourceDirectories)\u0022\r\n      LibraryProjectIntermediatePath=\u0022$(_AndroidLibrayProjectIntermediatePath)\u0022\r\n      StampDirectory=\u0022$(_AndroidStampDirectory)\u0022\u003E\r\n    \u003COutput TaskParameter=\u0022Output\u0022 ItemName=\u0022_LibraryResourceDirectories\u0022 /\u003E\r\n    \u003COutput TaskParameter=\u0022LibraryResourceFiles\u0022 ItemName=\u0022_LibraryResourceFiles\u0022 /\u003E\r\n    \u003COutput TaskParameter=\u0022LibraryResourceFiles\u0022 ItemName=\u0022_CompileResourcesInputs\u0022 /\u003E\r\n  \u003C/CollectNonEmptyDirectories\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CFileWrites Include=\u0022@(_LibraryResourceDirectories-\u003E\u0027%(FilesCache)\u0027)\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n\u003C/Target\u003E\r\n\r\n\u003CTarget Name=\u0022_ConvertResourcesCases\u0022\r\n    Inputs=\u0022@(_AndroidMSBuildAllProjects);$(_AndroidBuildPropertiesCache);@(AndroidResource);@(_LibraryResourceDirectories-\u003E\u0027%(StampFile)\u0027)\u0022\r\n    Outputs=\u0022$(_AndroidStampDirectory)_ConvertResourcesCases.stamp\u0022\r\n    DependsOnTargets=\u0022_CollectLibraryResourceDirectories;$(_BeforeConvertResourcesCases)\u0022\r\n  \u003E\r\n  \u003CMakeDir Directories=\u0022$(_AndroidLibraryFlatArchivesDirectory)\u0022 Condition=\u0022!Exists(\u0027$(_AndroidLibraryFlatArchivesDirectory)\u0027)\u0022 /\u003E\r\n  \u003CMakeDir Directories=\u0022$(_AndroidLibraryFlatFilesDirectory)\u0022 Condition=\u0022!Exists(\u0027$(_AndroidLibraryFlatFilesDirectory)\u0027)\u0022 /\u003E\r\n  \u003C!-- Change cases so we support mixed case resource names --\u003E\r\n  \u003CConvertResourcesCases\r\n      ContinueOnError=\u0022$(DesignTimeBuild)\u0022\r\n      AndroidConversionFlagFile=\u0022$(_AndroidStampDirectory)_ConvertResourcesCases.stamp\u0022\r\n      CustomViewMapFile=\u0022$(_CustomViewMapFile)\u0022\r\n      ResourceDirectories=\u0022$(MonoAndroidResDirIntermediate);@(_LibraryResourceDirectories)\u0022\r\n  /\u003E\r\n  \u003CTouch Files=\u0022$(_AndroidStampDirectory)_ConvertResourcesCases.stamp\u0022 AlwaysCreate=\u0022True\u0022 /\u003E\r\n\u003C/Target\u003E\r\n\r\n\u003CTarget Name=\u0022_CalculateResourceFileName\u0022\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003C_CompileResourcesInputs Include=\u0022@(_AndroidResourceDest)\u0022\u003E\r\n      \u003CStampFile\u003E%(Identity)\u003C/StampFile\u003E\r\n    \u003C/_CompileResourcesInputs\u003E\r\n    \u003C_CompiledFlatFiles Include=\u0022@(_CompileResourcesInputs-\u003E\u0027%(_ArchiveDirectory)%(_FlatFile)\u0027)\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n\u003C/Target\u003E\r\n\r\n\u003CTarget Name=\u0022_CompileResources\u0022\r\n    Inputs=\u0022@(_AndroidMSBuildAllProjects);$(_AndroidBuildPropertiesCache);@(_CompileResourcesInputs)\u0022\r\n    Outputs=\u0022@(_CompileResourcesInputs-\u003E\u0027%(_ArchiveDirectory)%(_FlatFile)\u0027)\u0022\r\n    DependsOnTargets=\u0022$(_BeforeCompileResources);_ConvertResourcesCases;_CalculateResourceFileName\u0022\r\n  \u003E\r\n  \u003CAapt2Compile\r\n      ContinueOnError=\u0022$(DesignTimeBuild)\u0022\r\n      DaemonMaxInstanceCount=\u0022$(Aapt2DaemonMaxInstanceCount)\u0022\r\n      DaemonKeepInDomain=\u0022$(_Aapt2DaemonKeepInDomain)\u0022\r\n      ExtraArgs=\u0022$(AndroidAapt2CompileExtraArgs)\u0022\r\n      FlatFilesDirectory=\u0022$(_AndroidLibraryFlatFilesDirectory)\u0022\r\n      FlatArchivesDirectory=\u0022$(_AndroidLibraryFlatArchivesDirectory)\u0022\r\n      ResourcesToCompile=\u0022@(_CompileResourcesInputs)\u0022\r\n      ResourceDirectories=\u0022$(MonoAndroidResDirIntermediate)\u0022\r\n      ToolPath=\u0022$(Aapt2ToolPath)\u0022\r\n      ToolExe=\u0022$(Aapt2ToolExe)\u0022\r\n  /\u003E\r\n\u003C/Target\u003E\r\n\r\n\u003CTarget Name=\u0022_Aapt2UpdateAndroidResgenInputs\u0022\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003C_UpdateAndroidResgenInputs\u003E\r\n      $(_UpdateAndroidResgenInputs);\r\n      @(_CompiledFlatFiles);\r\n      @(_LibraryResourceDirectoryStamps);\r\n    \u003C/_UpdateAndroidResgenInputs\u003E\r\n    \u003C_CreateBaseApkInputs\u003E\r\n      $(_CreateBaseApkInputs);\r\n      @(_CompiledFlatFiles);\r\n      @(_LibraryResourceDirectoryStamps);\r\n    \u003C/_CreateBaseApkInputs\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\u003C/Target\u003E\r\n\r\n\u003CTarget Name=\u0022_UpdateAndroidResgenAapt2\u0022\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003CAndroidAapt2LinkExtraArgs Condition=\u0022 $(AndroidResgenExtraArgs.Contains(\u0027--no-version-vectors\u0027)) And !($(AndroidAapt2LinkExtraArgs.Contains(\u0027--no-version-vectors\u0027))) \u0022\u003E--no-version-vectors $(AndroidAapt2LinkExtraArgs) \u003C/AndroidAapt2LinkExtraArgs\u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CAapt2Link\r\n      Condition=\u0022 \u0027$(_AndroidResourceDesignerFile)\u0027 != \u0027\u0027 \u0022\r\n      ContinueOnError=\u0022$(DesignTimeBuild)\u0022\r\n      DaemonMaxInstanceCount=\u0022$(Aapt2DaemonMaxInstanceCount)\u0022\r\n      DaemonKeepInDomain=\u0022$(_Aapt2DaemonKeepInDomain)\u0022\r\n      AssemblyIdentityMapFile=\u0022$(_AndroidLibrayProjectAssemblyMapFile)\u0022\r\n      ImportsDirectory=\u0022$(_LibraryProjectImportsDirectoryName)\u0022\r\n      OutputImportDirectory=\u0022$(_AndroidLibrayProjectIntermediatePath)\u0022\r\n      OutputFile=\u0022$(ResgenTemporaryDirectory)\\resources.apk\u0022\r\n      PackageName=\u0022$(_AndroidPackage)\u0022\r\n      JavaPlatformJarPath=\u0022$(JavaPlatformJarPath)\u0022\r\n      JavaDesignerOutputDirectory=\u0022$(ResgenTemporaryDirectory)\u0022\r\n      CompiledResourceFlatFiles=\u0022@(_CompiledFlatFiles)\u0022\r\n      ManifestFiles=\u0022$(ResgenTemporaryDirectory)\\AndroidManifest.xml\u0022\r\n      AdditionalAndroidResourcePaths=\u0022@(_LibraryResourceDirectories)\u0022\r\n      YieldDuringToolExecution=\u0022$(YieldDuringToolExecution)\u0022\r\n      ResourceSymbolsTextFile=\u0022$(IntermediateOutputPath)R.txt\u0022\r\n      ResourceDirectories=\u0022$(MonoAndroidResDirIntermediate)\u0022\r\n      ExtraArgs=\u0022$(AndroidAapt2LinkExtraArgs)\u0022\r\n      ToolPath=\u0022$(Aapt2ToolPath)\u0022\r\n      ToolExe=\u0022$(Aapt2ToolExe)\u0022\r\n      UncompressedFileExtensions=\u0022$(AndroidStoreUncompressedFileExtensions)\u0022\r\n  /\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CFileWrites Include=\u0022$(IntermediateOutputPath)R.txt\u0022 Condition=\u0022 Exists (\u0027$(IntermediateOutputPath)R.txt\u0027) \u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n\u003C/Target\u003E\r\n\r\n\u003CTarget Name=\u0022_FixupCustomViewsForAapt2\u0022\r\n    Condition=\u0022 \u0027@(_ProcessedCustomViews-\u003ECount())\u0027 != \u00270\u0027 \u0022\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003C_ItemsToFixup Include=\u0022@(_CompileResourcesInputs)\u0022 Condition=\u0022 \u0027@(_ProcessedCustomViews-\u003E\u0027%(Identity)\u0027)\u0027 == \u0027%(Identity)\u0027 \u0022/\u003E\r\n  \u003C/ItemGroup\u003E\r\n  \u003CAapt2Compile\r\n      Condition=\u0022 \u0027@(_ItemsToFixup-\u003ECount())\u0027 != \u00270\u0027 \u0022\r\n      ContinueOnError=\u0022$(DesignTimeBuild)\u0022\r\n      DaemonMaxInstanceCount=\u0022$(Aapt2DaemonMaxInstanceCount)\u0022\r\n      DaemonKeepInDomain=\u0022$(_Aapt2DaemonKeepInDomain)\u0022\r\n      ResourcesToCompile=\u0022@(_ItemsToFixup)\u0022\r\n      ResourceDirectories=\u0022$(MonoAndroidResDirIntermediate);@(_LibraryResourceDirectories)\u0022\r\n      ExtraArgs=\u0022$(AndroidAapt2CompileExtraArgs)\u0022\r\n      FlatFilesDirectory=\u0022$(_AndroidLibraryFlatFilesDirectory)\u0022\r\n      FlatArchivesDirectory=\u0022$(_AndroidLibraryFlatArchivesDirectory)\u0022\r\n      ToolPath=\u0022$(Aapt2ToolPath)\u0022\r\n      ToolExe=\u0022$(Aapt2ToolExe)\u0022\u003E\r\n    \u003COutput TaskParameter=\u0022CompiledResourceFlatFiles\u0022 ItemName=\u0022_UpdatedFlatFiles\u0022 /\u003E\r\n  \u003C/Aapt2Compile\u003E\r\n  \u003CTouch Files=\u0022$(_AndroidResgenFlagFile)\u0022 AlwaysCreate=\u0022True\u0022 Condition=\u0022 \u0027@(_UpdatedFlatFiles-\u003ECount())\u0027 != \u00270\u0027 \u0022 /\u003E\r\n\u003C/Target\u003E\r\n\r\n\u003CTarget Name=\u0022_CreateBaseApkWithAapt2\u0022\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003C_ProtobufFormat Condition=\u0022 \u0027$(AndroidPackageFormat)\u0027 == \u0027aab\u0027 \u0022\u003ETrue\u003C/_ProtobufFormat\u003E\r\n    \u003C_ProtobufFormat Condition=\u0022 \u0027$(_ProtobufFormat)\u0027 == \u0027\u0027 \u0022\u003EFalse\u003C/_ProtobufFormat\u003E\r\n    \u003C_Aapt2ProguardRules Condition=\u0022 \u0027$(AndroidLinkTool)\u0027 != \u0027\u0027 \u0022\u003E$(IntermediateOutputPath)aapt_rules.txt\u003C/_Aapt2ProguardRules\u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CAapt2Link\r\n      AndroidManifestFile=\u0022$(_AndroidManifestAbs)\u0022\r\n      CompiledResourceFlatFiles=\u0022@(_CompiledFlatFiles)\u0022\r\n      DaemonMaxInstanceCount=\u0022$(Aapt2DaemonMaxInstanceCount)\u0022\r\n      DaemonKeepInDomain=\u0022$(_Aapt2DaemonKeepInDomain)\u0022\r\n      ResourceDirectories=\u0022$(MonoAndroidResDirIntermediate)\u0022\r\n      AssemblyIdentityMapFile=\u0022$(_AndroidLibrayProjectAssemblyMapFile)\u0022\r\n      ImportsDirectory=\u0022$(_LibraryProjectImportsDirectoryName)\u0022\r\n      OutputImportDirectory=\u0022$(_AndroidLibrayProjectIntermediatePath)\u0022\r\n      OutputFile=\u0022$(_PackagedResources)\u0022\r\n      AdditionalAndroidResourcePaths=\u0022@(_LibraryResourceDirectories)\u0022\r\n      YieldDuringToolExecution=\u0022$(YieldDuringToolExecution)\u0022\r\n      PackageName=\u0022$(_AndroidPackage)\u0022\r\n      JavaPlatformJarPath=\u0022$(JavaPlatformJarPath)\u0022\r\n      VersionCodePattern=\u0022$(AndroidVersionCodePattern)\u0022\r\n      VersionCodeProperties=\u0022$(AndroidVersionCodeProperties)\u0022\r\n      SupportedAbis=\u0022@(_BuildTargetAbis)\u0022\r\n      CreatePackagePerAbi=\u0022$(AndroidCreatePackagePerAbi)\u0022\r\n      AssetsDirectory=\u0022$(MonoAndroidAssetsDirIntermediate)\u0022\r\n      AdditionalAndroidAssetPaths=\u0022@(LibraryAssetDirectories)\u0022\r\n      AndroidSdkPlatform=\u0022$(_AndroidApiLevel)\u0022\r\n      JavaDesignerOutputDirectory=\u0022$(AaptTemporaryDirectory)\u0022\r\n      ManifestFiles=\u0022$(IntermediateOutputPath)android\\AndroidManifest.xml\u0022\r\n      ProtobufFormat=\u0022$(_ProtobufFormat)\u0022\r\n      ExtraArgs=\u0022$(AndroidAapt2LinkExtraArgs)\u0022\r\n      ToolPath=\u0022$(Aapt2ToolPath)\u0022\r\n      ToolExe=\u0022$(Aapt2ToolExe)\u0022\r\n      UncompressedFileExtensions=\u0022$(AndroidStoreUncompressedFileExtensions)\u0022\r\n      ProguardRuleOutput=\u0022$(_Aapt2ProguardRules)\u0022\r\n  /\u003E\r\n  \u003CItemGroup Condition=\u0022 \u0027$(_Aapt2ProguardRules)\u0027 != \u0027\u0027 And Exists(\u0027$(_Aapt2ProguardRules)\u0027) \u0022\u003E\r\n    \u003CProguardConfiguration Include=\u0022$(_Aapt2ProguardRules)\u0022 /\u003E\r\n    \u003CFileWrites Include=\u0022$(_Aapt2ProguardRules)\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n\u003C/Target\u003E\r\n\u003C/Project\u003E\r\n","Selections":[{"Caret":10173,"Start":0,"End":12033}],"FilePath":"C:\\Program Files\\dotnet\\packs\\Microsoft.Android.Sdk.Windows\\33.0.68\\tools\\Xamarin.Android.Aapt2.targets","Language":null}],"PreSelectedSkill":null,"CorrelationId":{"Guid":"38ab498a-dfc2-47ad-9f24-927a58b0c6bc"}}},"Response":{"Content":"To ignore the \u0060bin\u0060 folder, you can add a line of code to the \u0060.gitignore\u0060 file in your repository. Here\u0027s an example of what the \u0060.gitignore\u0060 file should look like:\n\n\u0060\u0060\u0060Git\n# Visual Studio / Visual Studio for Mac\n.vs/\n\n# ReSharper\n_ReSharper*/\n\n# Bin and Obj Folders\n**/bin/\n**/obj/\n\u0060\u0060\u0060\n\nThis will exclude all \u0060bin\u0060 directories in your repository, regardless of depth.\n \nTo ensure that this file is up-to-date, you should include it in a version control system and ensure that it\u0027s checked in at the appropriate time.","Type":0,"Status":1,"FollowUpPrompts":["Why is it important to ignore folders in git?","Are there any other folders that I should ignore?"]},"SelectedFunctionName":"Explain","LoggedSkillInvocations":null}
